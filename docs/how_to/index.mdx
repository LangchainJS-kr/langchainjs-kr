---
sidebar_position: 0
sidebar_class_name: hidden
pagination_prev: null
pagination_next: null
---

# 사용 가이드

여기에는 "~를 어떻게 하지?" 유형의 질문에 대한 답변이 나와 있습니다.
이 가이드는 목표 지향적이며 구체적이기 때문에 특정 작업을 완료하는 데 도움이 됩니다.
개념에 대한 설명은 [개념 가이드](/docs/concepts/)를 참조하세요.
단계별 안내는 [튜토리얼](/docs/tutorials)을 참조하세요.
모든 클래스와 함수에 대한 포괄적인 설명은 [API 레퍼런스](https://v02.api.js.langchain.com/index.html)를 참조하세요.

## 설치

- [LangChain 패키지 설치 하는 법](/docs/how_to/installation/)

## 주요 기능

이 내용은 LangChain을 사용하는 데 핵심이 되는 기능들을 강조합니다.

- [LLM에서 구조화된 데이터 반환 받는 법](/docs/how_to/structured_output/)
- [채팅 모델을 사용하여 도구 호출하는 법](/docs/how_to/tool_calling/)
- [스트림 runnables 사용하는 법](/docs/how_to/streaming)
- [LLM 앱 디버그 하는 법](/docs/how_to/debugging/)

## LangChain Expression Language (LCEL)

LangChain Expression Language는 커스텀 체인들을 임의로 생성하는 방법입니다. [`Runnable`](https://api.js.langchain.com/classes/langchain_core_runnables.Runnable.html) 프로토콜 위에서 구축됩니다.

[**LCEL cheatsheet**](/docs/how_to/lcel_cheatsheet/): 주요 LCEL 프리미티브 사용 방법에 대한 간략한 개요를 확인해보세요.

- [runnables 체인 사용하는 법](/docs/how_to/sequence)
- [스트림 runnables 사용하는 법](/docs/how_to/streaming)
- [runnable들을 병렬로 실행하는 법](/docs/how_to/parallel/)
- [런타임 인자를 runnable에 추가하는 법](/docs/how_to/binding/)
- [커스텀 함수 실행하는 법](/docs/how_to/functions)
- [인자를 한 단계에서 다음 단계로 넘기는 법](/docs/how_to/passthrough)
- [체인 상태에 값 추가하는 법](/docs/how_to/assign)
- [메세지 내역 추가하는 법](/docs/how_to/message_history)
- [체인 내 실행을 라우팅하는 법](/docs/how_to/routing)
- [폴백 추가하는 법](/docs/how_to/fallbacks)

## 컴포넌트

애플리케이션을 구축할 때 사용할 수 있는 핵심 빌딩 블록입니다.

### 프롬프트 템플릿

프롬프트 템플릿은 사용자 입력을 언어 모델에 전달할 수 있는 형식으로 포맷팅하는 작업을 담당합니다.

- [few shot 예제 사용하는 법](/docs/how_to/few_shot_examples)
- [채팅 모델안에서 few shot 예제 사용하는 법 ](/docs/how_to/few_shot_examples_chat/)
- [부분적으로 포맷된 프롬프트 템플릿 사용하는 법](/docs/how_to/prompts_partial)
- [프롬프트를 같이 구성하는 법](/docs/how_to/prompts_composition)

### 예제 선택기

예제 선택기는 프롬프트에 전달할 적절한 few shot 예제를 선택하는 역할을 합니다.

- [예제 선택기를 사용하는 법](/docs/how_to/example_selectors)
- [길이에 따라 예제 선택하는 법](/docs/how_to/example_selectors_length_based)
- [의미적 유사성에 따라 예제 선택하는 법](/docs/how_to/example_selectors_similarity)

### 채팅 모델

채팅 모델은 메시지를 받아 메시지를 출력하는 새로운 형태의 언어 모델입니다.

- [도구/함수 호출하는 법](/docs/how_to/tool_calling)
- [구조화된 출력 반환 받는 법](/docs/how_to/structured_output)
- [모델 응답 캐시하는 법](/docs/how_to/chat_model_caching)
- [커스텀 채팅 모델 클래스 생성하는 법](/docs/how_to/custom_chat)
- [로그 확률 구하는 법](/docs/how_to/logprobs)
- [응답을 스트리밍하는 법](/docs/how_to/chat_streaming)
- [토큰 사용량 추적하는 법](/docs/how_to/chat_token_usage_tracking)

### LLMs

LangChain에서 LLMs라고 부르는 것은 문자열을 입력받아 문자열을 출력하는 기존 형태의 언어 모델입니다.

- [모델 응답 캐시하는 법](/docs/how_to/llm_caching)
- [커스텀 LLM 클래스 생성하는 법](/docs/how_to/custom_llm)
- [응답을 스트리밍하는 법](/docs/how_to/streaming_llm)
- [토큰 사용량 추적하는 법](/docs/how_to/llm_token_usage_tracking)

### 출력 파서

출력 파서는 LLM의 출력을 받아 더 구조화된 형식으로 파싱하는 역할을 합니다.

- [출력 파서를 사용해서 LLM 응답을 구조화된 형식으로 파싱하는 법](/docs/how_to/output_parser_structured)
- [JSON 출력 파싱하는 법](/docs/how_to/output_parser_json)
- [XML 출력 파싱하는 법](/docs/how_to/output_parser_xml)
- [출력 파싱에서 발생하는 오류 수정하는 법](/docs/how_to/output_parser_fixing/)

### 문서 로더

문서 로더는 다양한 소스로부터 문서를 로드하는 역할을 합니다.

- [CSV 데이터 로드하는 법](/docs/how_to/document_loader_csv)
- [디렉토리에서 데이터 로드하는 법](/docs/how_to/document_loader_directory)
- [PDF 파일 로드하는 법](/docs/how_to/document_loader_pdf)
- [커스텀 문서 로더 작성하는 법](/docs/how_to/document_loader_custom)
- [HTML 데이터 로드하는 법](/docs/how_to/document_loader_html)
- [Markdown 데이터 로드하는 법](/docs/how_to/document_loader_markdown)

### 텍스트 스플리터

텍스트 스플리터는 문서를 조각으로 나누어 검색에 사용할 수 있도록 합니다.

- [텍스트를 재귀적으로 나누는 법](/docs/how_to/recursive_text_splitter)
- [특정 문자를 기준으로 나누는 법](/docs/how_to/character_text_splitter)
- [코드를 나누는 법](/docs/how_to/code_splitter)
- [토큰별로 나누는 법](/docs/how_to/split_by_token)

### 임베딩 모델

임베딩 모델은 텍스트를 받아서 숫자 형태의 표현으로 변환합니다.

- [텍스트 데이터를 임베딩하는 법](/docs/how_to/embed_text)
- [임베딩 결과를 캐싱하는 법](/docs/how_to/caching_embeddings)

### 벡터 스토어

벡터 스토어는 임베딩을 효율적으로 저장하고 검색할 수 있는 데이터베이스입니다.

- [벡터 스토어 생성 및 쿼리하는 법](/docs/how_to/vectorstores)

### 검색기

검색기는 쿼리를 받아 관련 문서를 반환하는 역할을 합니다.

- [벡터 스토어를 사용하여 데이터 검색하는 법](/docs/how_to/vectorstore_retriever)
- [데이터 검색을 위한 다중 쿼리 생성하는 법](/docs/how_to/multiple_queries)
- [컨텍스트 압축을 사용하여 검색된 데이터 압축하는 법](/docs/how_to/contextual_compression)
- [커스텀 검색기 클래스 작성하는 법](/docs/how_to/custom_retriever)
- [문서당 여러 임베딩 생성하는 법](/docs/how_to/multi_vector)
- [청크에 대한 전체 문서 검색하는 법](/docs/how_to/parent_document_retriever)
- [메타데이터 필터 생성하는 법](/docs/how_to/self_query)
- [시간 가중 검색기 생성하는 법](/docs/how_to/time_weighted_vectorstore)
- [검색 지연 시간 줄이는 법](/docs/how_to/reduce_retrieval_latency)

### 인덱싱

인덱싱은 벡터 스토어를 기본 데이터 소스와 동기화하는 과정입니다.

- [데이터를 재인덱싱하여 벡터 스토어를 기본 데이터 소스와 동기화하는 법](/docs/how_to/indexing)

### 도구

LangChain 도구는 도구에 대한 설명(언어 모델에 전달할 설명)과 호출할 함수의 구현을 포함합니다.

- [커스텀 도구 생성하는 법](/docs/how_to/custom_tools)
- [내장 도구 및 내장 툴킷 사용하는 법](/docs/how_to/tools_builtin)
- [채팅 모델을 사용하여 도구 호출하는 법](/docs/how_to/tool_calling/)
- [LLM 및 채팅 모델에 애드혹 도구 호출 기능 추가하는 법](/docs/how_to/tools_prompting)
- [멀티 모달 데이터를 사용하여 도구 호출하는 법](/docs/how_to/tool_calls_multi_modal)

### 에이전트

:::note

에이전트에 대한 심층 가이드가 필요하면 [LangGraph](https://langchain-ai.github.io/langgraphjs/) 문서를 참조하세요.

:::

- [레거시 LangChain 에이전트(AgentExecutor) 사용하는 법](/docs/how_to/agent_executor)

### 콜백

- [런타임에 콜백 전달하는 법](/docs/how_to/callbacks_runtime)
- [모듈에 콜백을 연결하는 법](/docs/how_to/callbacks_attach)
- [모듈 생성자에 콜백을 전달하는 법](/docs/how_to/callbacks_constructor)
- [커스텀 콜백 핸들러 만드는 법](/docs/how_to/custom_callbacks)
- [백그라운드에서 콜백을 실행하는 법](/docs/how_to/callbacks_backgrounding)

### 커스텀

모든 LangChain 컴포넌트는 자체 버전을 지원하도록 쉽게 확장할 수 있습니다.

- [커스텀 채팅 모델 클래스 생성하는 법](/docs/how_to/custom_chat)
- [커스텀 LLM 클래스 생성하는 법](/docs/how_to/custom_llm)
- [커스텀 리트리버 클래스 작성하는 법](/docs/how_to/custom_retriever)
- [커스텀 문서 로더 작성하는 법](/docs/how_to/document_loader_custom)
- [커스텀 도구 정의하는 법](/docs/how_to/custom_tools)
- [커스텀 콜백 핸들러 만드는 법](/docs/how_to/custom_callbacks)

## 유즈 케이스

이 가이드들은 특정 유즈 케이스에 대한 세부 정보를 다룹니다.

### RAG와 Q&A

검색 증강 생성(RAG)은 LLM을 외부 데이터 소스에 연결하는 방법입니다.

- [채팅 내역 추가하는 법](/docs/how_to/qa_chat_history_how_to/)
- [스트리밍하는 법](/docs/how_to/qa_streaming/)
- [출처 반환하는 법](/docs/how_to/qa_sources/)
- [인용 반환하는 법](/docs/how_to/qa_citations/)
- [사용자별 검색하는 법](/docs/how_to/qa_per_user/)

### 추출

추출은 LLM을 사용하여 비구조화된 텍스트에서 구조화된 정보를 가져오는 것입니다.

- [참조 예제를 사용하는 법](/docs/how_to/extraction_examples/)
- [긴 텍스트를 처리하는 법](/docs/how_to/extraction_long_text/)
- [함수 호출을 사용하지 않고 추출하는 법](/docs/how_to/extraction_parse)

### 챗봇

챗봇은 LLM을 사용하여 대화를 하는 것을 의미합니다.

- [메모리 관리하는 법](/docs/how_to/chatbots_memory)
- [검색하는 법](/docs/how_to/chatbots_retrieval)
- [도구 사용하는 법](/docs/how_to/chatbots_tools)

### 쿼리 분석

쿼리 분석은 LLM을 사용하여 검색기에 보낼 쿼리를 생성하는 작업입니다.

- [프롬프트에 예제 추가하는 법](/docs/how_to/query_few_shot)
- [쿼리가 생성되지 않는 경우 처리하는 법](/docs/how_to/query_no_queries)
- [여러 쿼리를 처리하는 법](/docs/how_to/query_multiple_queries)
- [여러 검색기를 처리하는 법](/docs/how_to/query_multiple_retrievers)
- [필터를 구성하는 법](/docs/how_to/query_constructing_filters)
- [고유 값이 많은 범주형 변수를 처리하는 법](/docs/how_to/query_high_cardinality)

### SQL + CSV 통한 Q&A

LLMs를 사용하여 테이블 형식 데이터에 대한 질의 응답을 할 수 있습니다.

- [프롬프트를 사용하여 결과를 개선하는 법](/docs/how_to/sql_prompting)
- [쿼리 유효성 검사를 하는 법](/docs/how_to/sql_query_checking)
- [대규모 데이터베이스를 처리하는 법](/docs/how_to/sql_large_db)

### 그래프 데이터베이스를 통한 Q&A

LLMs를 사용하여 그래프 데이터베이스에 대한 질의 응답을 할 수 있습니다.

- [값을 데이터베이스에 매핑하는 법](/docs/how_to/graph_mapping)
- [데이터베이스에 시멘틱 계층 추가하는 법](/docs/how_to/graph_semantic)
- [프롬프트를 사용하여 결과를 개선하는 법](/docs/how_to/graph_prompting)
- [지식 그래프를 구성하는 법](/docs/how_to/graph_constructing)

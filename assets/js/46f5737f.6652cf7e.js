"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9935],{6960:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var a=t(74848),r=t(28453),o=t(78847),s=t(27846);const i={sidebar_class_name:"hidden",title:"How to add a semantic layer over the database"},l=void 0,c={id:"how_to/graph_semantic",title:"How to add a semantic layer over the database",description:"You can use database queries to retrieve information from a graph",source:"@site/docs/how_to/graph_semantic.mdx",sourceDirName:"how_to",slug:"/how_to/graph_semantic",permalink:"/docs/how_to/graph_semantic",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/how_to/graph_semantic.mdx",tags:[],version:"current",frontMatter:{sidebar_class_name:"hidden",title:"How to add a semantic layer over the database"},sidebar:"tutorialSidebar",previous:{title:"How to improve results with prompting",permalink:"/docs/how_to/graph_prompting"},next:{title:"How to reindex data to keep your vectorstore in-sync with the underlying data source",permalink:"/docs/how_to/indexing"}},u={},d=[{value:"Setup",id:"setup",level:2},{value:"Install dependencies",id:"install-dependencies",level:4},...o.toc,{value:"Set environment variables",id:"set-environment-variables",level:4},{value:"Custom tools with Cypher templates",id:"custom-tools-with-cypher-templates",level:2},{value:"OpenAI Agent",id:"openai-agent",level:2}];function p(e){const n={a:"a",code:"code",h2:"h2",h4:"h4",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"You can use database queries to retrieve information from a graph\ndatabase like Neo4j. One option is to use LLMs to generate Cypher\nstatements. While that option provides excellent flexibility, the\nsolution could be brittle and not consistently generating precise Cypher\nstatements. Instead of generating Cypher statements, we can implement\nCypher templates as tools in a semantic layer that an LLM agent can\ninteract with."}),"\n",(0,a.jsxs)("figure",{children:[(0,a.jsx)("img",{src:"../../static/img/graph_semantic.png",alt:"graph_semantic.png"}),(0,a.jsx)("figcaption",{"aria-hidden":"true",children:"graph_semantic.png"})]}),"\n",(0,a.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,a.jsx)(n.h4,{id:"install-dependencies",children:"Install dependencies"}),"\n","\n",(0,a.jsx)(o.default,{}),"\n",(0,a.jsx)(s.A,{children:(0,a.jsx)(n.p,{children:"langchain @langchain/community @langchain/openai neo4j-driver zod"})}),"\n",(0,a.jsx)(n.h4,{id:"set-environment-variables",children:"Set environment variables"}),"\n",(0,a.jsx)(n.p,{children:"We\u2019ll use OpenAI in this example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-env",children:"OPENAI_API_KEY=your-api-key\n\n# Optional, use LangSmith for best-in-class observability\nLANGSMITH_API_KEY=your-api-key\nLANGCHAIN_TRACING_V2=true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Next, we need to define Neo4j credentials. Follow ",(0,a.jsx)(n.a,{href:"https://neo4j.com/docs/operations-manual/current/installation/",children:"these installation\nsteps"}),"\nto set up a Neo4j database."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-env",children:'NEO4J_URI="bolt://localhost:7687"\nNEO4J_USERNAME="neo4j"\nNEO4J_PASSWORD="password"\n'})}),"\n",(0,a.jsx)(n.p,{children:"The below example will create a connection with a Neo4j database and\nwill populate it with example data about movies and their actors."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import "neo4j-driver";\nimport { Neo4jGraph } from "@langchain/community/graphs/neo4j_graph";\n\nconst url = Deno.env.get("NEO4J_URI");\nconst username = Deno.env.get("NEO4J_USER");\nconst password = Deno.env.get("NEO4J_PASSWORD");\nconst graph = await Neo4jGraph.initialize({ url, username, password });\n\n// Import movie information\nconst moviesQuery = `LOAD CSV WITH HEADERS FROM \n\'https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/movies/movies_small.csv\'\nAS row\nMERGE (m:Movie {id:row.movieId})\nSET m.released = date(row.released),\n    m.title = row.title,\n    m.imdbRating = toFloat(row.imdbRating)\nFOREACH (director in split(row.director, \'|\') | \n    MERGE (p:Person {name:trim(director)})\n    MERGE (p)-[:DIRECTED]->(m))\nFOREACH (actor in split(row.actors, \'|\') | \n    MERGE (p:Person {name:trim(actor)})\n    MERGE (p)-[:ACTED_IN]->(m))\nFOREACH (genre in split(row.genres, \'|\') | \n    MERGE (g:Genre {name:trim(genre)})\n    MERGE (m)-[:IN_GENRE]->(g))`;\n\nawait graph.query(moviesQuery);\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Schema refreshed successfully.\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"[]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"custom-tools-with-cypher-templates",children:"Custom tools with Cypher templates"}),"\n",(0,a.jsx)(n.p,{children:"A semantic layer consists of various tools exposed to an LLM that it can\nuse to interact with a knowledge graph. They can be of various\ncomplexity. You can think of each tool in a semantic layer as a\nfunction."}),"\n",(0,a.jsx)(n.p,{children:"The function we will implement is to retrieve information about movies\nor their cast."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'const descriptionQuery = `MATCH (m:Movie|Person)\nWHERE m.title CONTAINS $candidate OR m.name CONTAINS $candidate\nMATCH (m)-[r:ACTED_IN|HAS_GENRE]-(t)\nWITH m, type(r) as type, collect(coalesce(t.name, t.title)) as names\nWITH m, type+": "+reduce(s="", n IN names | s + n + ", ") as types\nWITH m, collect(types) as contexts\nWITH m, "type:" + labels(m)[0] + "\\ntitle: "+ coalesce(m.title, m.name) \n       + "\\nyear: "+coalesce(m.released,"") +"\\n" +\n       reduce(s="", c in contexts | s + substring(c, 0, size(c)-2) +"\\n") as context\nRETURN context LIMIT 1`;\n\nconst getInformation = async (entity: string) => {\n  try {\n    const data = await graph.query(descriptionQuery, { candidate: entity });\n    return data[0]["context"];\n  } catch (error) {\n    return "No information was found";\n  }\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can observe that we have defined the Cypher statement used to\nretrieve information. Therefore, we can avoid generating Cypher\nstatements and use the LLM agent to only populate the input parameters.\nTo provide additional information to an LLM agent about when to use the\ntool and their input parameters, we wrap the function as a tool."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { StructuredTool } from "@langchain/core/tools";\nimport { z } from "zod";\n\nconst informationInput = z.object({\n  entity: z.string().describe("movie or a person mentioned in the question"),\n});\n\nclass InformationTool extends StructuredTool {\n  schema = informationInput;\n\n  name = "Information";\n\n  description =\n    "useful for when you need to answer questions about various actors or movies";\n\n  async _call(input: z.infer<typeof informationInput>): Promise<string> {\n    return getInformation(input.entity);\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"openai-agent",children:"OpenAI Agent"}),"\n",(0,a.jsx)(n.p,{children:"LangChain expression language makes it very convenient to define an\nagent to interact with a graph database over the semantic layer."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { ChatOpenAI } from "@langchain/openai";\nimport { AgentExecutor } from "langchain/agents";\nimport { formatToOpenAIFunctionMessages } from "langchain/agents/format_scratchpad";\nimport { OpenAIFunctionsAgentOutputParser } from "langchain/agents/openai/output_parser";\nimport { convertToOpenAIFunction } from "@langchain/core/utils/function_calling";\nimport {\n  ChatPromptTemplate,\n  MessagesPlaceholder,\n} from "@langchain/core/prompts";\nimport { AIMessage, BaseMessage, HumanMessage } from "@langchain/core/messages";\nimport { RunnableSequence } from "@langchain/core/runnables";\n\nconst llm = new ChatOpenAI({ model: "gpt-3.5-turbo", temperature: 0 });\nconst tools = [new InformationTool()];\n\nconst llmWithTools = llm.bind({\n  functions: tools.map(convertToOpenAIFunction),\n});\n\nconst prompt = ChatPromptTemplate.fromMessages([\n  [\n    "system",\n    "You are a helpful assistant that finds information about movies and recommends them. If tools require follow up questions, make sure to ask the user for clarification. Make sure to include any available options that need to be clarified in the follow up questions Do only the things the user specifically requested.",\n  ],\n  new MessagesPlaceholder("chat_history"),\n  ["human", "{input}"],\n  new MessagesPlaceholder("agent_scratchpad"),\n]);\n\nconst _formatChatHistory = (chatHistory) => {\n  const buffer: Array<BaseMessage> = [];\n  for (const [human, ai] of chatHistory) {\n    buffer.push(new HumanMessage({ content: human }));\n    buffer.push(new AIMessage({ content: ai }));\n  }\n  return buffer;\n};\n\nconst agent = RunnableSequence.from([\n  {\n    input: (x) => x.input,\n    chat_history: (x) => {\n      if ("chat_history" in x) {\n        return _formatChatHistory(x.chat_history);\n      }\n      return [];\n    },\n    agent_scratchpad: (x) => {\n      if ("steps" in x) {\n        return formatToOpenAIFunctionMessages(x.steps);\n      }\n      return [];\n    },\n  },\n  prompt,\n  llmWithTools,\n  new OpenAIFunctionsAgentOutputParser(),\n]);\n\nconst agentExecutor = new AgentExecutor({ agent, tools });\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'await agentExecutor.invoke({ input: "Who played in Casino?" });\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'{\n  input: "Who played in Casino?",\n  output: \'The movie "Casino" starred James Woods, Joe Pesci, Robert De Niro, and Sharon Stone.\'\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>s});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var o=t(74848);function s(e){let{children:n,hidden:t,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>j});var a=t(96540),r=t(34164),o=t(23104),s=t(56347),i=t(205),l=t(57485),c=t(31682),u=t(89466);function d(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,c.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.W6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l.aZ)(o),(0,a.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(r.location.search);n.set(o,e),r.replace({...r.location,search:n.toString()})}),[o,r])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=p(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[c,d]=m({queryString:t,groupId:r}),[g,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,o]=(0,u.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:r}),b=(()=>{const e=c??g;return h({value:e,tabValues:o})?e:null})();(0,i.A)((()=>{b&&l(b)}),[b]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),f(e)}),[d,f,o]),tabValues:o}}var f=t(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=t(74848);function y(e){let{className:n,block:t,selectedValue:a,selectValue:s,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),u=e=>{const n=e.currentTarget,t=l.indexOf(n),r=i[t].value;r!==a&&(c(n),s(r))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>l.push(e),onKeyDown:d,onClick:u,...o,className:(0,r.A)("tabs__item",b.tabItem,o?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function x(e){let{lazy:n,children:t,selectedValue:r}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function w(e){const n=g(e);return(0,v.jsxs)("div",{className:(0,r.A)("tabs-container",b.tabList),children:[(0,v.jsx)(y,{...n,...e}),(0,v.jsx)(x,{...n,...e})]})}function j(e){const n=(0,f.A)();return(0,v.jsx)(w,{...e,children:d(e.children)},String(n))}},27846:(e,n,t)=>{t.d(n,{A:()=>i});t(96540);var a=t(11470),r=t(19365),o=t(21432),s=t(74848);function i(e){let{children:n}=e;return(0,s.jsxs)(a.A,{groupId:"npm2yarn",children:[(0,s.jsx)(r.A,{value:"npm",label:"npm",children:(0,s.jsxs)(o.A,{language:"bash",children:["npm i ",n]})}),(0,s.jsx)(r.A,{value:"yarn",label:"yarn",default:!0,children:(0,s.jsxs)(o.A,{language:"bash",children:["yarn add ",n]})}),(0,s.jsx)(r.A,{value:"pnpm",label:"pnpm",children:(0,s.jsxs)(o.A,{language:"bash",children:["pnpm add ",n]})})]})}}}]);
(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5601],{54785:(e,s,n)=>{"use strict";n.r(s),n.d(s,{assets:()=>h,contentTitle:()=>c,default:()=>p,frontMatter:()=>d,metadata:()=>l,toc:()=>g});var a=n(74848),t=n(28453),r=n(64428),o=n(79072),i=n.n(o);const d={sidebar_class_name:"node-only"},c="Cassandra KV",l={id:"integrations/stores/cassandra_storage",title:"Cassandra KV",description:"This example demonstrates how to setup chat history storage using the CassandraKVStore BaseStore integration. Note there is a CassandraChatMessageHistory",source:"@site/docs/integrations/stores/cassandra_storage.mdx",sourceDirName:"integrations/stores",slug:"/integrations/stores/cassandra_storage",permalink:"/docs/integrations/stores/cassandra_storage",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/integrations/stores/cassandra_storage.mdx",tags:[],version:"current",frontMatter:{sidebar_class_name:"node-only"},sidebar:"integrations",previous:{title:"Stores",permalink:"/docs/integrations/stores/"},next:{title:"File System Store",permalink:"/docs/integrations/stores/file_system"}},h={},g=[{value:"Setup",id:"setup",level:2},{value:"Apache Cassandra\xae",id:"apache-cassandra",level:3},{value:"Astra DB",id:"astra-db",level:3},{value:"Usage",id:"usage",level:2}];function m(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.h1,{id:"cassandra-kv",children:"Cassandra KV"}),"\n",(0,a.jsxs)(s.p,{children:["This example demonstrates how to setup chat history storage using the ",(0,a.jsx)(s.code,{children:"CassandraKVStore"})," ",(0,a.jsx)(s.code,{children:"BaseStore"})," integration. Note there is a ",(0,a.jsx)(s.code,{children:"CassandraChatMessageHistory"}),"\nintegration which may be easier to use for chat history storage; the ",(0,a.jsx)(s.code,{children:"CassandraKVStore"})," is useful if you want a more general-purpose key-value store with\nprefixable keys."]}),"\n",(0,a.jsx)(s.h2,{id:"setup",children:"Setup"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",metastring:"npm2yarn",children:"npm install cassandra-driver\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Depending on your database providers, the specifics of how to connect to the database will vary. We will create a document ",(0,a.jsx)(s.code,{children:"configConnection"})," which will be used as part of the store configuration."]}),"\n",(0,a.jsx)(s.h3,{id:"apache-cassandra",children:"Apache Cassandra\xae"}),"\n",(0,a.jsxs)(s.p,{children:["Storage Attached Indexes (used by ",(0,a.jsx)(s.code,{children:"yieldKeys"}),") are supported in ",(0,a.jsx)(s.a,{href:"https://cassandra.apache.org/_/blog/Apache-Cassandra-5.0-Features-Storage-Attached-Indexes.html",children:"Apache Cassandra\xae 5.0"})," and above. You can use a standard connection document, for example:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"const configConnection = {\n  contactPoints: ['h1', 'h2'],\n  localDataCenter: 'datacenter1',\n  credentials: {\n    username: <...> as string,\n    password: <...> as string,\n  },\n};\n"})}),"\n",(0,a.jsx)(s.h3,{id:"astra-db",children:"Astra DB"}),"\n",(0,a.jsx)(s.p,{children:"Astra DB is a cloud-native Cassandra-as-a-Service platform."}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["Create an ",(0,a.jsx)(s.a,{href:"https://astra.datastax.com/register",children:"Astra DB account"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:["Create a ",(0,a.jsx)(s.a,{href:"https://astra.datastax.com/createDatabase",children:"vector enabled database"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:["Create a ",(0,a.jsx)(s.a,{href:"https://docs.datastax.com/en/astra/docs/manage-application-tokens.html",children:"token"})," for your database."]}),"\n"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"const configConnection = {\n  serviceProviderArgs: {\n    astra: {\n      token: <...> as string,\n      endpoint: <...> as string,\n    },\n  },\n};\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Instead of ",(0,a.jsx)(s.code,{children:"endpoint:"}),", you many provide property ",(0,a.jsx)(s.code,{children:"datacenterID:"})," and optionally ",(0,a.jsx)(s.code,{children:"regionName:"}),"."]}),"\n",(0,a.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n","\n",(0,a.jsx)(r.A,{language:"typescript",children:i()})]})}function p(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},79072:e=>{e.exports={content:'import { CassandraKVStore } from "@langchain/community/storage/cassandra";\nimport { AIMessage, HumanMessage } from "@langchain/core/messages";\n\n// This document is the Cassandra driver connection document; the example is to AstraDB but\n// any valid Cassandra connection can be used.\nconst configConnection = {\n  serviceProviderArgs: {\n    astra: {\n      token: "YOUR_TOKEN_OR_LOAD_FROM_ENV" as string,\n      endpoint: "YOUR_ENDPOINT_OR_LOAD_FROM_ENV" as string,\n    },\n  },\n};\n\nconst store = new CassandraKVStore({\n  ...configConnection,\n  keyspace: "test", // keyspace must exist\n  table: "test_kv", // table will be created if it does not exist\n  keyDelimiter: ":", // optional, default is "/"\n});\n\n// Define our encoder/decoder for converting between strings and Uint8Arrays\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\n/**\n * Here you would define your LLM and chat chain, call\n * the LLM and eventually get a list of messages.\n * For this example, we\'ll assume we already have a list.\n */\nconst messages = Array.from({ length: 5 }).map((_, index) => {\n  if (index % 2 === 0) {\n    return new AIMessage("ai stuff...");\n  }\n  return new HumanMessage("human stuff...");\n});\n\n// Set your messages in the store\n// The key will be prefixed with `message:id:` and end\n// with the index.\nawait store.mset(\n  messages.map((message, index) => [\n    `message:id:${index}`,\n    encoder.encode(JSON.stringify(message)),\n  ])\n);\n\n// Now you can get your messages from the store\nconst retrievedMessages = await store.mget(["message:id:0", "message:id:1"]);\n// Make sure to decode the values\nconsole.log(retrievedMessages.map((v) => decoder.decode(v)));\n\n/**\n[\n  \'{"id":["langchain","AIMessage"],"kwargs":{"content":"ai stuff..."}}\',\n  \'{"id":["langchain","HumanMessage"],"kwargs":{"content":"human stuff..."}}\'\n]\n */\n\n// Or, if you want to get back all the keys you can call\n// the `yieldKeys` method.\n// Optionally, you can pass a key prefix to only get back\n// keys which match that prefix.\nconst yieldedKeys = [];\nfor await (const key of store.yieldKeys("message:id:")) {\n  yieldedKeys.push(key);\n}\n\n// The keys are not encoded, so no decoding is necessary\nconsole.log(yieldedKeys);\n/**\n[\n  \'message:id:2\',\n  \'message:id:1\',\n  \'message:id:3\',\n  \'message:id:0\',\n  \'message:id:4\'\n]\n */\n\n// Finally, let\'s delete the keys from the store\nawait store.mdelete(yieldedKeys);\n',imports:[{local:"CassandraKVStore",imported:"CassandraKVStore",source:"@langchain/community/storage/cassandra"},{local:"AIMessage",imported:"AIMessage",source:"@langchain/core/messages"},{local:"HumanMessage",imported:"HumanMessage",source:"@langchain/core/messages"}]}}}]);
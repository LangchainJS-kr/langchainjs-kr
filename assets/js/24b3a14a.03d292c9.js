(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[991],{81745:(e,s,n)=>{"use strict";n.r(s),n.d(s,{assets:()=>g,contentTitle:()=>c,default:()=>m,frontMatter:()=>d,metadata:()=>l,toc:()=>h});var t=n(74848),a=n(28453),r=n(64428),i=n(59764),o=n.n(i);const d={},c="Upstash Redis",l={id:"integrations/stores/upstash_redis_storage",title:"Upstash Redis",description:"This example demonstrates how to setup chat history storage using the UpstashRedisStore BaseStore integration.",source:"@site/docs/integrations/stores/upstash_redis_storage.mdx",sourceDirName:"integrations/stores",slug:"/integrations/stores/upstash_redis_storage",permalink:"/docs/integrations/stores/upstash_redis_storage",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/integrations/stores/upstash_redis_storage.mdx",tags:[],version:"current",frontMatter:{},sidebar:"integrations",previous:{title:"IORedis",permalink:"/docs/integrations/stores/ioredis_storage"},next:{title:"Vercel KV",permalink:"/docs/integrations/stores/vercel_kv_storage"}},g={},h=[{value:"Setup",id:"setup",level:2},{value:"Usage",id:"usage",level:2}];function u(e){const s={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"upstash-redis",children:"Upstash Redis"}),"\n",(0,t.jsxs)(s.p,{children:["This example demonstrates how to setup chat history storage using the ",(0,t.jsx)(s.code,{children:"UpstashRedisStore"})," ",(0,t.jsx)(s.code,{children:"BaseStore"})," integration."]}),"\n",(0,t.jsx)(s.h2,{id:"setup",children:"Setup"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",metastring:"npm2yarn",children:"npm install @upstash/redis\n"})}),"\n",(0,t.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n","\n",(0,t.jsx)(r.A,{language:"typescript",children:o()})]})}function m(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},59764:e=>{e.exports={content:'import { Redis } from "@upstash/redis";\nimport { UpstashRedisStore } from "@langchain/community/storage/upstash_redis";\nimport { AIMessage, HumanMessage } from "@langchain/core/messages";\n\n// Pro tip: define a helper function for getting your client\n// along with handling the case where your environment variables\n// are not set.\nconst getClient = () => {\n  if (\n    !process.env.UPSTASH_REDIS_REST_URL ||\n    !process.env.UPSTASH_REDIS_REST_TOKEN\n  ) {\n    throw new Error(\n      "UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN must be set in the environment"\n    );\n  }\n  const client = new Redis({\n    url: process.env.UPSTASH_REDIS_REST_URL,\n    token: process.env.UPSTASH_REDIS_REST_TOKEN,\n  });\n  return client;\n};\n\n// Define the client and store\nconst client = getClient();\nconst store = new UpstashRedisStore({\n  client,\n});\n// Define our encoder/decoder for converting between strings and Uint8Arrays\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n/**\n * Here you would define your LLM and chat chain, call\n * the LLM and eventually get a list of messages.\n * For this example, we\'ll assume we already have a list.\n */\nconst messages = Array.from({ length: 5 }).map((_, index) => {\n  if (index % 2 === 0) {\n    return new AIMessage("ai stuff...");\n  }\n  return new HumanMessage("human stuff...");\n});\n// Set your messages in the store\n// The key will be prefixed with `message:id:` and end\n// with the index.\nawait store.mset(\n  messages.map((message, index) => [\n    `message:id:${index}`,\n    encoder.encode(JSON.stringify(message)),\n  ])\n);\n// Now you can get your messages from the store\nconst retrievedMessages = await store.mget(["message:id:0", "message:id:1"]);\n// Make sure to decode the values\nconsole.log(retrievedMessages.map((v) => decoder.decode(v)));\n/**\n[\n  \'{"id":["langchain","AIMessage"],"kwargs":{"content":"ai stuff..."}}\',\n  \'{"id":["langchain","HumanMessage"],"kwargs":{"content":"human stuff..."}}\'\n]\n */\n// Or, if you want to get back all the keys you can call\n// the `yieldKeys` method.\n// Optionally, you can pass a key prefix to only get back\n// keys which match that prefix.\nconst yieldedKeys = [];\nfor await (const key of store.yieldKeys("message:id")) {\n  yieldedKeys.push(key);\n}\n// The keys are not encoded, so no decoding is necessary\nconsole.log(yieldedKeys);\n/**\n[\n  \'message:id:2\',\n  \'message:id:1\',\n  \'message:id:3\',\n  \'message:id:0\',\n  \'message:id:4\'\n]\n */\n// Finally, let\'s delete the keys from the store\nawait store.mdelete(yieldedKeys);\n',imports:[{local:"UpstashRedisStore",imported:"UpstashRedisStore",source:"@langchain/community/storage/upstash_redis"},{local:"AIMessage",imported:"AIMessage",source:"@langchain/core/messages"},{local:"HumanMessage",imported:"HumanMessage",source:"@langchain/core/messages"}]}}}]);
(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1318],{95895:(e,s,n)=>{"use strict";n.r(s),n.d(s,{assets:()=>m,contentTitle:()=>l,default:()=>y,frontMatter:()=>d,metadata:()=>c,toc:()=>h});var t=n(74848),a=n(28453),o=n(64428),i=n(24452),r=n.n(i);const d={sidebar_class_name:"node-only"},l="File System Store",c={id:"integrations/stores/file_system",title:"File System Store",description:"Only available on Node.js.",source:"@site/docs/integrations/stores/file_system.mdx",sourceDirName:"integrations/stores",slug:"/integrations/stores/file_system",permalink:"/docs/integrations/stores/file_system",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/integrations/stores/file_system.mdx",tags:[],version:"current",frontMatter:{sidebar_class_name:"node-only"},sidebar:"integrations",previous:{title:"Cassandra KV",permalink:"/docs/integrations/stores/cassandra_storage"},next:{title:"In Memory Store",permalink:"/docs/integrations/stores/in_memory"}},m={},h=[{value:"Usage",id:"usage",level:2}];function g(e){const s={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"file-system-store",children:"File System Store"}),"\n",(0,t.jsx)(s.admonition,{title:"Compatibility",type:"tip",children:(0,t.jsx)(s.p,{children:"Only available on Node.js."})}),"\n",(0,t.jsxs)(s.p,{children:["This example demonstrates how to setup chat history storage using the ",(0,t.jsx)(s.code,{children:"LocalFileStore"})," KV store integration."]}),"\n",(0,t.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsx)(s.admonition,{type:"info",children:(0,t.jsxs)(s.p,{children:["The path passed to the ",(0,t.jsx)(s.code,{children:".fromPath"})," must be a directory, not a file."]})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"LocalFileStore"})," is a wrapper around the ",(0,t.jsx)(s.code,{children:"fs"})," module for storing data as key-value pairs.\nEach key value pair has its own file nested inside the directory passed to the ",(0,t.jsx)(s.code,{children:".fromPath"})," method.\nThe file name is the key and inside contains the value of the key."]}),"\n","\n",(0,t.jsx)(o.A,{language:"typescript",children:r()})]})}function y(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}},24452:e=>{e.exports={content:'import fs from "fs";\nimport { LocalFileStore } from "langchain/storage/file_system";\nimport { AIMessage, HumanMessage } from "@langchain/core/messages";\n\n// Instantiate the store using the `fromPath` method.\nconst store = await LocalFileStore.fromPath("./messages");\n// Define our encoder/decoder for converting between strings and Uint8Arrays\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n/**\n * Here you would define your LLM and chat chain, call\n * the LLM and eventually get a list of messages.\n * For this example, we\'ll assume we already have a list.\n */\nconst messages = Array.from({ length: 5 }).map((_, index) => {\n  if (index % 2 === 0) {\n    return new AIMessage("ai stuff...");\n  }\n  return new HumanMessage("human stuff...");\n});\n// Set your messages in the store\n// The key will be prefixed with `message:id:` and end\n// with the index.\nawait store.mset(\n  messages.map((message, index) => [\n    `message:id:${index}`,\n    encoder.encode(JSON.stringify(message)),\n  ])\n);\n// Now you can get your messages from the store\nconst retrievedMessages = await store.mget(["message:id:0", "message:id:1"]);\n// Make sure to decode the values\nconsole.log(retrievedMessages.map((v) => decoder.decode(v)));\n/**\n[\n  \'{"id":["langchain","AIMessage"],"kwargs":{"content":"ai stuff..."}}\',\n  \'{"id":["langchain","HumanMessage"],"kwargs":{"content":"human stuff..."}}\'\n]\n */\n// Or, if you want to get back all the keys you can call\n// the `yieldKeys` method.\n// Optionally, you can pass a key prefix to only get back\n// keys which match that prefix.\nconst yieldedKeys = [];\nfor await (const key of store.yieldKeys("message:id:")) {\n  yieldedKeys.push(key);\n}\n// The keys are not encoded, so no decoding is necessary\nconsole.log(yieldedKeys);\n/**\n[\n  \'message:id:2\',\n  \'message:id:1\',\n  \'message:id:3\',\n  \'message:id:0\',\n  \'message:id:4\'\n]\n */\n// Finally, let\'s delete the keys from the store\n// and delete the file.\nawait store.mdelete(yieldedKeys);\nawait fs.promises.rm("./messages", { recursive: true, force: true });\n',imports:[{local:"LocalFileStore",imported:"LocalFileStore",source:"langchain/storage/file_system"},{local:"AIMessage",imported:"AIMessage",source:"@langchain/core/messages"},{local:"HumanMessage",imported:"HumanMessage",source:"@langchain/core/messages"}]}}}]);
(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2458],{77427:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>d,default:()=>y,frontMatter:()=>h,metadata:()=>p,toc:()=>g});var a=t(74848),o=t(28453),i=t(78847),r=t(64428),s=t(85963),l=t.n(s),c=t(76171),u=t.n(c);const h={sidebar_class_name:"hidden",pagination_prev:null,pagination_next:null},d="How to do query validation",p={id:"how_to/sql_query_checking",title:"How to do query validation",description:"This guide assumes familiarity with the following:",source:"@site/docs/how_to/sql_query_checking.mdx",sourceDirName:"how_to",slug:"/how_to/sql_query_checking",permalink:"/docs/how_to/sql_query_checking",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/how_to/sql_query_checking.mdx",tags:[],version:"current",frontMatter:{sidebar_class_name:"hidden",pagination_prev:null,pagination_next:null},sidebar:"tutorialSidebar"},m={},g=[{value:"Setup",id:"setup",level:2},...i.toc,{value:"Query checker",id:"query-checker",level:2},{value:"Next steps",id:"next-steps",level:2}];function q(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"how-to-do-query-validation",children:"How to do query validation"}),"\n",(0,a.jsxs)(n.admonition,{title:"Prerequisites",type:"info",children:[(0,a.jsx)(n.p,{children:"This guide assumes familiarity with the following:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"/docs/tutorials/sql_qa",children:"Question answering over SQL data"})}),"\n"]})]}),"\n",(0,a.jsx)(n.p,{children:"Perhaps the most error-prone part of any SQL chain or agent is writing valid and safe SQL queries.\nIn this guide we'll go over some strategies for validating our queries and handling invalid queries."}),"\n",(0,a.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,a.jsx)(n.p,{children:"First, get required packages and set environment variables:"}),"\n","\n",(0,a.jsx)(i.default,{}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npm install @langchain/community @langchain/openai typeorm sqlite3\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'export OPENAI_API_KEY="your api key"\n# Uncomment the below to use LangSmith. Not required.\n# export LANGCHAIN_API_KEY="your api key"\n# export LANGCHAIN_TRACING_V2=true\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The below example will use a SQLite connection with Chinook database. Follow these ",(0,a.jsx)(n.a,{href:"https://database.guide/2-sample-databases-sqlite/",children:"installation steps"})," to create ",(0,a.jsx)(n.code,{children:"Chinook.db"})," in the same directory as this notebook:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Save ",(0,a.jsx)(n.a,{href:"https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql",children:"this"})," file as ",(0,a.jsx)(n.code,{children:"Chinook_Sqlite.sql"})]}),"\n",(0,a.jsxs)(n.li,{children:["Run sqlite3 ",(0,a.jsx)(n.code,{children:"Chinook.db"})]}),"\n",(0,a.jsxs)(n.li,{children:["Run ",(0,a.jsx)(n.code,{children:".read Chinook_Sqlite.sql"})]}),"\n",(0,a.jsxs)(n.li,{children:["Test ",(0,a.jsx)(n.code,{children:"SELECT * FROM Artist LIMIT 10;"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Now, ",(0,a.jsx)(n.code,{children:"Chinhook.db"})," is in our directory and we can interface with it using the Typeorm-driven ",(0,a.jsx)(n.code,{children:"SqlDatabase"})," class:"]}),"\n","\n",(0,a.jsx)(r.A,{language:"typescript",children:l()}),"\n",(0,a.jsx)(n.h2,{id:"query-checker",children:"Query checker"}),"\n",(0,a.jsx)(n.p,{children:"Perhaps the simplest strategy is to ask the model itself to check the original query for common mistakes.\nSuppose we have the following SQL query chain:"}),"\n","\n",(0,a.jsx)(r.A,{language:"typescript",children:u()}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,a.jsx)(n.p,{children:"You've now learned about some strategies to validate generated SQL queries."}),"\n",(0,a.jsxs)(n.p,{children:["Next, check out some of the other guides in this section, like ",(0,a.jsx)(n.a,{href:"/docs/how_to/sql_large_db",children:"how to query over large databases"}),"."]})]})}function y(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(q,{...e})}):q(e)}},85963:e=>{e.exports={content:"import { SqlDatabase } from \"langchain/sql_db\";\nimport { DataSource } from \"typeorm\";\n\nconst datasource = new DataSource({\n  type: \"sqlite\",\n  database: \"../../../../Chinook.db\",\n});\nconst db = await SqlDatabase.fromDataSourceParams({\n  appDataSource: datasource,\n});\nconsole.log(db.allTables.map((t) => t.tableName));\n/**\n[\n  'Album',       'Artist',\n  'Customer',    'Employee',\n  'Genre',       'Invoice',\n  'InvoiceLine', 'MediaType',\n  'Playlist',    'PlaylistTrack',\n  'Track'\n]\n */\n",imports:[{local:"SqlDatabase",imported:"SqlDatabase",source:"langchain/sql_db"}]}},76171:e=>{e.exports={content:'import { StringOutputParser } from "@langchain/core/output_parsers";\nimport { ChatPromptTemplate, PromptTemplate } from "@langchain/core/prompts";\nimport { RunnableSequence } from "@langchain/core/runnables";\nimport { ChatOpenAI } from "@langchain/openai";\nimport { createSqlQueryChain } from "langchain/chains/sql_db";\nimport { SqlDatabase } from "langchain/sql_db";\nimport { DataSource } from "typeorm";\n\nconst datasource = new DataSource({\n  type: "sqlite",\n  database: "../../../../Chinook.db",\n});\nconst db = await SqlDatabase.fromDataSourceParams({\n  appDataSource: datasource,\n});\n\nconst llm = new ChatOpenAI({ model: "gpt-4", temperature: 0 });\nconst chain = await createSqlQueryChain({\n  llm,\n  db,\n  dialect: "sqlite",\n});\n\n/**\n * And we want to validate its outputs. We can do so by extending the chain with a second prompt and model call:\n */\n\nconst SYSTEM_PROMPT = `Double check the user\'s {dialect} query for common mistakes, including:\n- Using NOT IN with NULL values\n- Using UNION when UNION ALL should have been used\n- Using BETWEEN for exclusive ranges\n- Data type mismatch in predicates\n- Properly quoting identifiers\n- Using the correct number of arguments for functions\n- Casting to the correct data type\n- Using the proper columns for joins\n\nIf there are any of the above mistakes, rewrite the query. If there are no mistakes, just reproduce the original query.\n\nOutput the final SQL query only.`;\n\nconst prompt = await ChatPromptTemplate.fromMessages([\n  ["system", SYSTEM_PROMPT],\n  ["human", "{query}"],\n]).partial({ dialect: "sqlite" });\n\nconst validationChain = prompt.pipe(llm).pipe(new StringOutputParser());\n\nconst fullChain = RunnableSequence.from([\n  {\n    query: async (i: { question: string }) => chain.invoke(i),\n  },\n  validationChain,\n]);\nconst query = await fullChain.invoke({\n  question:\n    "What\'s the average Invoice from an American customer whose Fax is missing since 2003 but before 2010",\n});\nconsole.log("query", query);\n/**\nquery SELECT AVG("Total") FROM "Invoice" WHERE "CustomerId" IN (SELECT "CustomerId" FROM "Customer" WHERE "Country" = \'USA\' AND "Fax" IS NULL) AND "InvoiceDate" BETWEEN \'2003-01-01 00:00:00\' AND \'2009-12-31 23:59:59\'\n */\nconsole.log("db query results", await db.run(query));\n/**\ndb query results [{"AVG(\\"Total\\")":6.632999999999998}]\n */\n\n// -------------\n\n// You can see a LangSmith trace of the above chain here:\n// https://smith.langchain.com/public/d1131395-8477-47cd-8f74-e0c5491ea956/r\n\n// -------------\n\n// The obvious downside of this approach is that we need to make two model calls instead of one to generate our query.\n// To get around this we can try to perform the query generation and query check in a single model invocation:\n\nconst SYSTEM_PROMPT_2 = `You are a {dialect} expert. Given an input question, create a syntactically correct {dialect} query to run.\nUnless the user specifies in the question a specific number of examples to obtain, query for at most {top_k} results using the LIMIT clause as per {dialect}. You can order the results to return the most informative data in the database.\nNever query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes (") to denote them as delimited identifiers.\nPay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.\nPay attention to use date(\'now\') function to get the current date, if the question involves "today".\n\nOnly use the following tables:\n{table_info}\n\nWrite an initial draft of the query. Then double check the {dialect} query for common mistakes, including:\n- Using NOT IN with NULL values\n- Using UNION when UNION ALL should have been used\n- Using BETWEEN for exclusive ranges\n- Data type mismatch in predicates\n- Properly quoting identifiers\n- Using the correct number of arguments for functions\n- Casting to the correct data type\n- Using the proper columns for joins\n\nUse format:\n\nFirst draft: <<FIRST_DRAFT_QUERY>>\nFinal answer: <<FINAL_ANSWER_QUERY>>`;\n\nconst prompt2 = await PromptTemplate.fromTemplate(\n  `System: ${SYSTEM_PROMPT_2}\n\nHuman: {input}`\n).partial({ dialect: "sqlite" });\n\nconst parseFinalAnswer = (output: string): string =>\n  output.split("Final answer: ")[1];\n\nconst chain2 = (\n  await createSqlQueryChain({\n    llm,\n    db,\n    prompt: prompt2,\n    dialect: "sqlite",\n  })\n).pipe(parseFinalAnswer);\n\nconst query2 = await chain2.invoke({\n  question:\n    "What\'s the average Invoice from an American customer whose Fax is missing since 2003 but before 2010",\n});\nconsole.log("query2", query2);\n/**\nquery2 SELECT AVG("Total") FROM "Invoice" WHERE "CustomerId" IN (SELECT "CustomerId" FROM "Customer" WHERE "Country" = \'USA\' AND "Fax" IS NULL) AND date("InvoiceDate") BETWEEN date(\'2003-01-01\') AND date(\'2009-12-31\') LIMIT 5\n */\nconsole.log("db query results", await db.run(query2));\n\n/**\ndb query results [{"AVG(\\"Total\\")":6.632999999999998}]\n */\n\n// -------------\n\n// You can see a LangSmith trace of the above chain here:\n// https://smith.langchain.com/public/e21d6146-eca9-4de6-a078-808fd09979ea/r\n\n// -------------\n',imports:[{local:"StringOutputParser",imported:"StringOutputParser",source:"@langchain/core/output_parsers"},{local:"ChatPromptTemplate",imported:"ChatPromptTemplate",source:"@langchain/core/prompts"},{local:"PromptTemplate",imported:"PromptTemplate",source:"@langchain/core/prompts"},{local:"RunnableSequence",imported:"RunnableSequence",source:"@langchain/core/runnables"},{local:"ChatOpenAI",imported:"ChatOpenAI",source:"@langchain/openai"},{local:"createSqlQueryChain",imported:"createSqlQueryChain",source:"langchain/chains/sql_db"},{local:"SqlDatabase",imported:"SqlDatabase",source:"langchain/sql_db"}]}}}]);
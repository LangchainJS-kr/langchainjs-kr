"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7472],{11835:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var a=t(74848),r=t(28453),i=t(27846);const s={sidebar_position:4,title:"\ucd94\ucd9c \uccb4\uc778 \ub9cc\ub4e4\uae30",sidebar_class_name:"hidden",pagination_prev:null,pagination_next:null},o=void 0,l={id:"tutorials/extraction",title:"\ucd94\ucd9c \uccb4\uc778 \ub9cc\ub4e4\uae30",description:"In this tutorial, we will build a chain to extract structured",source:"@site/docs/tutorials/extraction.mdx",sourceDirName:"tutorials",slug:"/tutorials/extraction",permalink:"/docs/tutorials/extraction",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/tutorials/extraction.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"\ucd94\ucd9c \uccb4\uc778 \ub9cc\ub4e4\uae30",sidebar_class_name:"hidden",pagination_prev:null,pagination_next:null},sidebar:"tutorialSidebar"},c={},h=[{value:"Concepts",id:"concepts",level:2},{value:"Setup",id:"setup",level:2},{value:"Installation",id:"installation",level:3},{value:"LangSmith",id:"langsmith",level:3},{value:"The Schema",id:"the-schema",level:2},{value:"The Extractor",id:"the-extractor",level:2},{value:"Multiple Entities",id:"multiple-entities",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"In this tutorial, we will build a chain to extract structured\ninformation from unstructured text."}),"\n",(0,a.jsx)(n.admonition,{type:"important",children:(0,a.jsxs)(n.p,{children:["This tutorial will only work with models that support ",(0,a.jsx)(n.strong,{children:"function/tool\ncalling"})]})}),"\n",(0,a.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,a.jsxs)(n.p,{children:["Concepts we will cover are: - Using ",(0,a.jsx)(n.a,{href:"../../docs/concepts/#chat-models",children:"language\nmodels"})," - Using ",(0,a.jsx)(n.a,{href:"../../docs/concepts/#function-tool-calling",children:"function/tool\ncalling"})," - Debugging and\ntracing your application using\n",(0,a.jsx)(n.a,{href:"../../docs/concepts/#langsmith",children:"LangSmith"})]}),"\n",(0,a.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,a.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(n.p,{children:"To install LangChain run:"}),"\n","\n",(0,a.jsx)(i.A,{children:(0,a.jsx)(n.p,{children:"langchain"})}),"\n",(0,a.jsxs)(n.p,{children:["For more details, see our ",(0,a.jsx)(n.a,{href:"../../docs/how_to/installation/",children:"Installation\nguide"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"langsmith",children:"LangSmith"}),"\n",(0,a.jsxs)(n.p,{children:["Many of the applications you build with LangChain will contain multiple\nsteps with multiple invocations of LLM calls. As these applications get\nmore and more complex, it becomes crucial to be able to inspect what\nexactly is going on inside your chain or agent. The best way to do this\nis with ",(0,a.jsx)(n.a,{href:"https://smith.langchain.com",children:"LangSmith"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"After you sign up at the link above, make sure to set your environment\nvariables to start logging traces:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:'export LANGCHAIN_TRACING_V2="true"\nexport LANGCHAIN_API_KEY="..."\n'})}),"\n",(0,a.jsx)(n.h2,{id:"the-schema",children:"The Schema"}),"\n",(0,a.jsx)(n.p,{children:"First, we need to describe what information we want to extract from the\ntext."}),"\n",(0,a.jsxs)(n.p,{children:["We\u2019ll use ",(0,a.jsx)(n.a,{href:"https://zod.dev",children:"Zod"})," to define an example schema that\nextracts personal information."]}),"\n",(0,a.jsx)(i.A,{children:(0,a.jsx)(n.p,{children:"zod @langchain/core"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { z } from "zod";\n\nconst personSchema = z.object({\n  name: z.string().nullish().describe("The name of the person"),\n  hair_color: z\n    .string()\n    .nullish()\n    .describe("The color of the person\'s hair if known"),\n  height_in_meters: z.string().nullish().describe("Height measured in meters"),\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:"There are two best practices when defining schema:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Document the ",(0,a.jsx)(n.strong,{children:"attributes"})," and the ",(0,a.jsx)(n.strong,{children:"schema"})," itself: This\ninformation is sent to the LLM and is used to improve the quality of\ninformation extraction."]}),"\n",(0,a.jsxs)(n.li,{children:["Do not force the LLM to make up information! Above we used\n",(0,a.jsx)(n.code,{children:".nullish()"})," for the attributes allowing the LLM to output ",(0,a.jsx)(n.code,{children:"null"})," or\n",(0,a.jsx)(n.code,{children:"undefined"})," if it doesn\u2019t know the answer."]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"important",children:(0,a.jsx)(n.p,{children:"For best performance, document the schema well and make sure the model\nisn\u2019t force to return results if there\u2019s no information to be extracted\nin the text."})}),"\n",(0,a.jsx)(n.h2,{id:"the-extractor",children:"The Extractor"}),"\n",(0,a.jsx)(n.p,{children:"Let\u2019s create an information extractor using the schema we defined above."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { ChatPromptTemplate } from "@langchain/core/prompts";\n\n// Define a custom prompt to provide instructions and any additional context.\n// 1) You can add examples into the prompt template to improve extraction quality\n// 2) Introduce additional parameters to take context into account (e.g., include metadata\n//    about the document from which the text was extracted.)\nconst prompt = ChatPromptTemplate.fromMessages([\n  [\n    "system",\n    `You are an expert extraction algorithm.\nOnly extract relevant information from the text.\nIf you do not know the value of an attribute asked to extract,\nreturn null for the attribute\'s value.`,\n  ],\n  // Please see the how-to about improving performance with\n  // reference examples.\n  // ["placeholder", "{examples}"],\n  ["human", "{text}"],\n]);\n'})}),"\n",(0,a.jsx)(n.p,{children:"We need to use a model that supports function/tool calling."}),"\n",(0,a.jsxs)(n.p,{children:["Please review ",(0,a.jsx)(n.a,{href:"../../docs/concepts#function-tool-calling",children:"the\ndocumentation"})," for list of\nsome models that can be used with this API."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { ChatAnthropic } from "@langchain/anthropic";\n\nconst llm = new ChatAnthropic({\n  model: "claude-3-sonnet-20240229",\n  temperature: 0,\n});\n\nconst runnable = prompt.pipe(llm.withStructuredOutput(personSchema));\n\nconst text = "Alan Smith is 6 feet tall and has blond hair.";\nawait runnable.invoke({ text });\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'{ name: "Alan Smith", hair_color: "blond", height_in_meters: "1.83" }\n'})}),"\n",(0,a.jsxs)(n.admonition,{type:"important",children:[(0,a.jsx)(n.p,{children:"Extraction is Generative \ud83e\udd2f"}),(0,a.jsx)(n.p,{children:"LLMs are generative models, so they can do some pretty cool things like\ncorrectly extract the height of the person in meters even though it was\nprovided in feet!"})]}),"\n",(0,a.jsxs)(n.p,{children:["We can see the LangSmith trace\n",(0,a.jsx)(n.a,{href:"https://smith.langchain.com/public/3d44b7e8-e7ca-4e02-951d-3290ccc89d64/r",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Even though we defined our schema with the variable name ",(0,a.jsx)(n.code,{children:"personSchema"}),",\nZod is unable to infer this name and therefore does not pass it along to\nthe model. To help give the LLM more clues as to what your provided\nschema represents, you can also give the schema you pass to\n",(0,a.jsx)(n.code,{children:"withStructuredOutput()"})," a name:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'const runnable = prompt.pipe(\n  llm.withStructuredOutput(personSchema, { name: "person" })\n);\n\nconst text = "Alan Smith is 6 feet tall and has blond hair.";\n\nawait runnable.invoke({ text });\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'{ name: "Alan Smith", hair_color: "blond", height_in_meters: "1.83" }\n'})}),"\n",(0,a.jsx)(n.p,{children:"This can improve performance in many cases."}),"\n",(0,a.jsx)(n.h2,{id:"multiple-entities",children:"Multiple Entities"}),"\n",(0,a.jsxs)(n.p,{children:["In ",(0,a.jsx)(n.strong,{children:"most cases"}),", you should be extracting a list of entities rather\nthan a single entity."]}),"\n",(0,a.jsx)(n.p,{children:"This can be easily achieved using Zod by nesting models inside one\nanother."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { z } from "zod";\n\nconst personSchema = z.object({\n  name: z.string().nullish().describe("The name of the person"),\n  hair_color: z\n    .string()\n    .nullish()\n    .describe("The color of the person\'s hair if known"),\n  height_in_meters: z.number().nullish().describe("Height measured in meters"),\n});\n\nconst dataSchema = z.object({\n  people: z.array(personSchema).describe("Extracted data about people"),\n});\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"important",children:(0,a.jsxs)(n.p,{children:["Extraction might not be perfect here. Please continue to see how to use\n",(0,a.jsx)(n.strong,{children:"Reference Examples"})," to improve the quality of extraction, and see the\n",(0,a.jsx)(n.strong,{children:"guidelines"})," section!"]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'const runnable = prompt.pipe(llm.withStructuredOutput(dataSchema));\nconst text =\n  "My name is Jeff, my hair is black and i am 6 feet tall. Anna has the same color hair as me.";\nawait runnable.invoke({ text });\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'{\n  people: [\n    { name: "Jeff", hair_color: "black", height_in_meters: 1.83 },\n    { name: "Anna", hair_color: "black", height_in_meters: null }\n  ]\n}\n'})}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["When the schema accommodates the extraction of ",(0,a.jsx)(n.strong,{children:"multiple entities"}),", it\nalso allows the model to extract ",(0,a.jsx)(n.strong,{children:"no entities"})," if no relevant\ninformation is in the text by providing an empty list."]}),(0,a.jsxs)(n.p,{children:["This is usually a ",(0,a.jsx)(n.strong,{children:"good"})," thing! It allows specifying ",(0,a.jsx)(n.strong,{children:"required"}),"\nattributes on an entity without necessarily forcing the model to detect\nthis entity."]})]}),"\n",(0,a.jsxs)(n.p,{children:["We can see the LangSmith trace\n",(0,a.jsx)(n.a,{href:"https://smith.langchain.com/public/272096ab-9ac5-43f9-aa00-3b8443477d17/r",children:"here"})]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,a.jsx)(n.p,{children:"Now that you understand the basics of extraction with LangChain, you\u2019re\nready to proceed to the rest of the how-to guides:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../../docs/how_to/extraction_examples",children:"Add Examples"}),": Learn how to\nuse ",(0,a.jsx)(n.strong,{children:"reference examples"})," to improve performance."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../../docs/how_to/extraction_long_text",children:"Handle Long Text"}),": What\nshould you do if the text does not fit into the context window of\nthe LLM?"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../../docs/how_to/extraction_parse",children:"Use a Parsing Approach"}),": Use a\nprompt based approach to extract with models that do not support\n",(0,a.jsx)(n.strong,{children:"tool/function calling"}),"."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>s});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var i=t(74848);function s(e){let{children:n,hidden:t,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,s),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>y});var a=t(96540),r=t(34164),i=t(23104),s=t(56347),o=t(205),l=t(57485),c=t(31682),h=t(89466);function d(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,c.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const r=(0,s.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(r.location.search);n.set(i,e),r.replace({...r.location,search:n.toString()})}),[i,r])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=u(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[c,d]=m({queryString:t,groupId:r}),[x,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,i]=(0,h.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:r}),f=(()=>{const e=c??x;return p({value:e,tabValues:i})?e:null})();(0,o.A)((()=>{f&&l(f)}),[f]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),g(e)}),[d,g,i]),tabValues:i}}var g=t(92303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function j(e){let{className:n,block:t,selectedValue:a,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),h=e=>{const n=e.currentTarget,t=l.indexOf(n),r=o[t].value;r!==a&&(c(n),s(r))},d=e=>{let n=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>l.push(e),onKeyDown:d,onClick:h,...i,className:(0,r.A)("tabs__item",f.tabItem,i?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function v(e){let{lazy:n,children:t,selectedValue:r}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function w(e){const n=x(e);return(0,b.jsxs)("div",{className:(0,r.A)("tabs-container",f.tabList),children:[(0,b.jsx)(j,{...n,...e}),(0,b.jsx)(v,{...n,...e})]})}function y(e){const n=(0,g.A)();return(0,b.jsx)(w,{...e,children:d(e.children)},String(n))}},27846:(e,n,t)=>{t.d(n,{A:()=>o});t(96540);var a=t(11470),r=t(19365),i=t(21432),s=t(74848);function o(e){let{children:n}=e;return(0,s.jsxs)(a.A,{groupId:"npm2yarn",children:[(0,s.jsx)(r.A,{value:"npm",label:"npm",children:(0,s.jsxs)(i.A,{language:"bash",children:["npm i ",n]})}),(0,s.jsx)(r.A,{value:"yarn",label:"yarn",default:!0,children:(0,s.jsxs)(i.A,{language:"bash",children:["yarn add ",n]})}),(0,s.jsx)(r.A,{value:"pnpm",label:"pnpm",children:(0,s.jsxs)(i.A,{language:"bash",children:["pnpm add ",n]})})]})}}}]);
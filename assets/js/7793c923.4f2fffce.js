"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2196],{30402:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>a});var o=t(74848),s=t(28453);const i={sidebar_class_name:"hidden",title:"How to create custom Tools"},l=void 0,c={id:"how_to/custom_tools",title:"How to create custom Tools",description:"This guide assumes familiarity with the following concepts:",source:"@site/docs/how_to/custom_tools.mdx",sourceDirName:"how_to",slug:"/how_to/custom_tools",permalink:"/docs/how_to/custom_tools",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/how_to/custom_tools.mdx",tags:[],version:"current",frontMatter:{sidebar_class_name:"hidden",title:"How to create custom Tools"},sidebar:"tutorialSidebar",previous:{title:"How to write a custom retriever class",permalink:"/docs/how_to/custom_retriever"},next:{title:"How to debug your LLM apps",permalink:"/docs/how_to/debugging"}},r={},a=[{value:"<code>DynamicStructuredTool</code>",id:"dynamicstructuredtool",level:2},{value:"<code>DynamicTool</code>",id:"dynamictool",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.admonition,{title:"Prerequisites",type:"info",children:[(0,o.jsx)(n.p,{children:"This guide assumes familiarity with the following concepts:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"../../docs/concepts#tools",children:"LangChain tools"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"../../docs/concepts/#agents",children:"Agents"})}),"\n"]})]}),"\n",(0,o.jsxs)(n.p,{children:["When constructing your own agent, you will need to provide it with a\nlist of Tools that it can use. While LangChain includes some prebuilt\ntools, it can often be more useful to use tools that use custom logic.\nThis guide will walk you through how to use these ",(0,o.jsx)(n.code,{children:"Dynamic"})," tools."]}),"\n",(0,o.jsx)(n.p,{children:"In this guide, we will walk through how to do define a tool for two\nfunctions:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"A multiplier function that will multiply two numbers by each other"}),"\n",(0,o.jsx)(n.li,{children:"A made up search function that always returns the string \u201cLangChain\u201d"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The biggest difference here is that the first function requires an\nobject with multiple input fields, while the second one only accepts an\nobject with a single field. Some older agents only work with functions\nthat require single inputs, so it\u2019s important to understand the\ndistinction."}),"\n",(0,o.jsx)(n.h2,{id:"dynamicstructuredtool",children:(0,o.jsx)(n.code,{children:"DynamicStructuredTool"})}),"\n",(0,o.jsxs)(n.p,{children:["Newer and more advanced agents can handle more flexible tools that take\nmultiple inputs. You can use the\n",(0,o.jsx)(n.a,{href:"https://v02.api.js.langchain.com/classes/langchain_core_tools.DynamicStructuredTool.html",children:(0,o.jsx)(n.code,{children:"DynamicStructuredTool"})}),"\nclass to declare them. Here\u2019s an example - note that tools must always\nreturn strings!"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { DynamicStructuredTool } from "@langchain/core/tools";\nimport { z } from "zod";\n\nconst multiplyTool = new DynamicStructuredTool({\n  name: "multiply",\n  description: "multiply two numbers together",\n  schema: z.object({\n    a: z.number().describe("the first number to multiply"),\n    b: z.number().describe("the second number to multiply"),\n  }),\n  func: async ({ a, b }: { a: number; b: number }) => {\n    return (a * b).toString();\n  },\n});\n\nawait multiplyTool.invoke({ a: 8, b: 9 });\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:'"72"\n'})}),"\n",(0,o.jsx)(n.h2,{id:"dynamictool",children:(0,o.jsx)(n.code,{children:"DynamicTool"})}),"\n",(0,o.jsxs)(n.p,{children:["For older agents that require tools which accept only a single input,\nyou can pass the relevant parameters to the\n",(0,o.jsx)(n.a,{href:"https://v02.api.js.langchain.com/classes/langchain_core_tools.DynamicTool.html",children:(0,o.jsx)(n.code,{children:"DynamicTool"})}),"\nclass. This is useful when working with older agents that only support\ntools that accept a single input. In this case, no schema is required:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { DynamicTool } from "@langchain/core/tools";\n\nconst searchTool = new DynamicTool({\n  name: "search",\n  description: "look things up online",\n  func: async (_input: string) => {\n    return "LangChain";\n  },\n});\n\nawait searchTool.invoke("foo");\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:'"LangChain"\n'})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);
"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1904],{67059:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var o=n(74848),s=n(28453);const r={sidebar_class_name:"hidden",title:"How to recursively split text by characters"},i=void 0,a={id:"how_to/recursive_text_splitter",title:"How to recursively split text by characters",description:"This guide assumes familiarity with the following concepts:",source:"@site/docs/how_to/recursive_text_splitter.mdx",sourceDirName:"how_to",slug:"/how_to/recursive_text_splitter",permalink:"/docs/how_to/recursive_text_splitter",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/how_to/recursive_text_splitter.mdx",tags:[],version:"current",frontMatter:{sidebar_class_name:"hidden",title:"How to recursively split text by characters"},sidebar:"tutorialSidebar",previous:{title:"How to handle cases where no queries are generated",permalink:"/docs/how_to/query_no_queries"},next:{title:"How to reduce retrieval latency",permalink:"/docs/how_to/reduce_retrieval_latency"}},c={},l=[{value:"Next steps",id:"next-steps",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.admonition,{title:"Prerequisites",type:"info",children:[(0,o.jsx)(t.p,{children:"This guide assumes familiarity with the following concepts:"}),(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"../../docs/concepts#text-splitters",children:"Text splitters"})}),"\n"]})]}),"\n",(0,o.jsxs)(t.p,{children:["This text splitter is the recommended one for generic text. It is\nparameterized by a list of characters. It tries to split on them in\norder until the chunks are small enough. The default list is\n",(0,o.jsx)(t.code,{children:'["\\n\\n", "\\n", " ", ""]'}),". This has the effect of trying to keep all\nparagraphs (and then sentences, and then words) together as long as\npossible, as those would generically seem to be the strongest\nsemantically related pieces of text."]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"How the text is split: by list of characters."}),"\n",(0,o.jsx)(t.li,{children:"How the chunk size is measured: by number of characters."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Below we show example usage."}),"\n",(0,o.jsxs)(t.p,{children:["To obtain the string content directly, use ",(0,o.jsx)(t.code,{children:".splitText"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["To create LangChain\n",(0,o.jsx)(t.a,{href:"https://v02.api.js.langchain.com/classes/langchain_core_documents.Document.html",children:"Document"}),"\nobjects (e.g., for use in downstream tasks), use ",(0,o.jsx)(t.code,{children:".createDocuments"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";\n\nconst text = `Hi.\\n\\nI\'m Harrison.\\n\\nHow? Are? You?\\nOkay then f f f f.\nThis is a weird text to write, but gotta test the splittingggg some how.\\n\\n\nBye!\\n\\n-H.`;\nconst splitter = new RecursiveCharacterTextSplitter({\n  chunkSize: 10,\n  chunkOverlap: 1,\n});\n\nconst output = await splitter.createDocuments([text]);\n\nconsole.log(output.slice(0, 3));\n'})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-text",children:'[\n  Document {\n    pageContent: "Hi.",\n    metadata: { loc: { lines: { from: 1, to: 1 } } }\n  },\n  Document {\n    pageContent: "I\'m",\n    metadata: { loc: { lines: { from: 3, to: 3 } } }\n  },\n  Document {\n    pageContent: "Harrison.",\n    metadata: { loc: { lines: { from: 3, to: 3 } } }\n  }\n]\n'})}),"\n",(0,o.jsx)(t.p,{children:"You\u2019ll note that in the above example we are splitting a raw text string\nand getting back a list of documents. We can also split documents\ndirectly."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'import { Document } from "@langchain/core/documents";\nimport { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";\n\nconst text = `Hi.\\n\\nI\'m Harrison.\\n\\nHow? Are? You?\\nOkay then f f f f.\nThis is a weird text to write, but gotta test the splittingggg some how.\\n\\n\nBye!\\n\\n-H.`;\nconst splitter = new RecursiveCharacterTextSplitter({\n  chunkSize: 10,\n  chunkOverlap: 1,\n});\n\nconst docOutput = await splitter.splitDocuments([\n  new Document({ pageContent: text }),\n]);\n\nconsole.log(docOutput.slice(0, 3));\n'})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-text",children:'[\n  Document {\n    pageContent: "Hi.",\n    metadata: { loc: { lines: { from: 1, to: 1 } } }\n  },\n  Document {\n    pageContent: "I\'m",\n    metadata: { loc: { lines: { from: 3, to: 3 } } }\n  },\n  Document {\n    pageContent: "Harrison.",\n    metadata: { loc: { lines: { from: 3, to: 3 } } }\n  }\n]\n'})}),"\n",(0,o.jsxs)(t.p,{children:["You can customize the ",(0,o.jsx)(t.code,{children:"RecursiveCharacterTextSplitter"})," with arbitrary\nseparators by passing a ",(0,o.jsx)(t.code,{children:"separators"})," parameter like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";\nimport { Document } from "@langchain/core/documents";\n\nconst text = `Some other considerations include:\n\n- Do you deploy your backend and frontend together, or separately?\n- Do you deploy your backend co-located with your database, or separately?\n\n**Production Support:** As you move your LangChains into production, we\'d love to offer more hands-on support.\nFill out [this form](https://airtable.com/appwQzlErAS2qiP0L/shrGtGaVBVAz7NcV2) to share more about what you\'re building, and our team will get in touch.\n\n## Deployment Options\n\nSee below for a list of deployment options for your LangChain app. If you don\'t see your preferred option, please get in touch and we can add it to this list.`;\n\nconst splitter = new RecursiveCharacterTextSplitter({\n  chunkSize: 50,\n  chunkOverlap: 1,\n  separators: ["|", "##", ">", "-"],\n});\n\nconst docOutput = await splitter.splitDocuments([\n  new Document({ pageContent: text }),\n]);\n\nconsole.log(docOutput.slice(0, 3));\n'})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-text",children:'[\n  Document {\n    pageContent: "Some other considerations include:",\n    metadata: { loc: { lines: { from: 1, to: 1 } } }\n  },\n  Document {\n    pageContent: "- Do you deploy your backend and frontend together",\n    metadata: { loc: { lines: { from: 3, to: 3 } } }\n  },\n  Document {\n    pageContent: "r, or separately?",\n    metadata: { loc: { lines: { from: 3, to: 3 } } }\n  }\n]\n'})}),"\n",(0,o.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,o.jsx)(t.p,{children:"You\u2019ve now learned a method for splitting text by character."}),"\n",(0,o.jsxs)(t.p,{children:["Next, check out ",(0,o.jsx)(t.a,{href:"../../docs/how_to/code_splitter",children:"specific techinques for splitting on\ncode"})," or the ",(0,o.jsx)(t.a,{href:"../../docs/tutorials/rag",children:"full tutorial on\nretrieval-augmented generation"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);
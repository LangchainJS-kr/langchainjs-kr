"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7881],{56844:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var s=t(74848),a=t(28453);const o={sidebar_class_name:"hidden",title:"How to add chat history to a question-answering chain"},i=void 0,r={id:"how_to/qa_chat_history_how_to",title:"How to add chat history to a question-answering chain",description:"This guide assumes familiarity with the following:",source:"@site/docs/how_to/qa_chat_history_how_to.mdx",sourceDirName:"how_to",slug:"/how_to/qa_chat_history_how_to",permalink:"/docs/how_to/qa_chat_history_how_to",draft:!1,unlisted:!1,editUrl:"https://langchainjs-kr.site/docs/how_to/qa_chat_history_how_to.mdx",tags:[],version:"current",frontMatter:{sidebar_class_name:"hidden",title:"How to add chat history to a question-answering chain"},sidebar:"tutorialSidebar",previous:{title:"How to partially format prompt templates",permalink:"/docs/how_to/prompts_partial"},next:{title:"How to return citations",permalink:"/docs/how_to/qa_citations"}},l={},c=[{value:"Setup",id:"setup",level:2},{value:"Dependencies",id:"dependencies",level:3},{value:"LangSmith",id:"langsmith",level:3},{value:"Initial setup",id:"initial-setup",level:3},{value:"Contextualizing the question",id:"contextualizing-the-question",level:2},{value:"Chain with chat history",id:"chain-with-chat-history",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.admonition,{title:"Prerequisites",type:"info",children:[(0,s.jsx)(n.p,{children:"This guide assumes familiarity with the following:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../../docs/tutorials/rag/",children:"Retrieval-augmented generation"})}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"In many Q&A applications we want to allow the user to have a\nback-and-forth conversation, meaning the application needs some sort of\n\u201cmemory\u201d of past questions and answers, and some logic for incorporating\nthose into its current thinking."}),"\n",(0,s.jsxs)(n.p,{children:["In this guide we focus on ",(0,s.jsx)(n.strong,{children:"adding logic for incorporating historical\nmessages, and NOT on chat history management."})," Chat history management\nis ",(0,s.jsx)(n.a,{href:"../../docs/how_to/message_history",children:"covered here"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We\u2019ll work off of the Q&A app we built over the ",(0,s.jsx)(n.a,{href:"https://lilianweng.github.io/posts/2023-06-23-agent/",children:"LLM Powered Autonomous\nAgents"})," blog post\nby Lilian Weng. We\u2019ll need to update two things about our existing app:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prompt"}),": Update our prompt to support historical messages as an\ninput."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Contextualizing questions"}),": Add a sub-chain that takes the latest\nuser question and reformulates it in the context of the chat\nhistory. This is needed in case the latest question references some\ncontext from past messages. For example, if a user asks a follow-up\nquestion like \u201cCan you elaborate on the second point?\u201d, this cannot\nbe understood without the context of the previous message. Therefore\nwe can\u2019t effectively perform retrieval with a question like this."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["We\u2019ll use an OpenAI chat model and embeddings and a Memory vector store\nin this walkthrough, but everything shown here works with any\n",(0,s.jsx)(n.a,{href:"../../docs/concepts/#chat-models",children:"ChatModel"})," or\n",(0,s.jsx)(n.a,{href:"../../docs/concepts#llms",children:"LLM"}),",\n",(0,s.jsx)(n.a,{href:"../../docs/concepts#embedding-models",children:"Embeddings"}),", and\n",(0,s.jsx)(n.a,{href:"../../docs/concepts#vectorstores",children:"VectorStore"})," or\n",(0,s.jsx)(n.a,{href:"../../docs/concepts#retrievers",children:"Retriever"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"We\u2019ll use the following packages:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install --save langchain @langchain/openai cheerio\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We need to set environment variable ",(0,s.jsx)(n.code,{children:"OPENAI_API_KEY"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"export OPENAI_API_KEY=YOUR_KEY\n"})}),"\n",(0,s.jsx)(n.h3,{id:"langsmith",children:"LangSmith"}),"\n",(0,s.jsxs)(n.p,{children:["Many of the applications you build with LangChain will contain multiple\nsteps with multiple invocations of LLM calls. As these applications get\nmore and more complex, it becomes crucial to be able to inspect what\nexactly is going on inside your chain or agent. The best way to do this\nis with ",(0,s.jsx)(n.a,{href:"https://docs.smith.langchain.com",children:"LangSmith"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Note that LangSmith is not needed, but it is helpful. If you do want to\nuse LangSmith, after you sign up at the link above, make sure to set\nyour environment variables to start logging traces:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"export LANGCHAIN_TRACING_V2=true\nexport LANGCHAIN_API_KEY=YOUR_KEY\n"})}),"\n",(0,s.jsx)(n.h3,{id:"initial-setup",children:"Initial setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import "cheerio";\nimport { CheerioWebBaseLoader } from "langchain/document_loaders/web/cheerio";\nimport { RecursiveCharacterTextSplitter } from "langchain/text_splitter";\nimport { MemoryVectorStore } from "langchain/vectorstores/memory";\nimport { OpenAIEmbeddings, ChatOpenAI } from "@langchain/openai";\nimport { pull } from "langchain/hub";\nimport { ChatPromptTemplate } from "@langchain/core/prompts";\nimport {\n  RunnableSequence,\n  RunnablePassthrough,\n} from "@langchain/core/runnables";\nimport { StringOutputParser } from "@langchain/core/output_parsers";\n\nimport { createStuffDocumentsChain } from "langchain/chains/combine_documents";\n\nconst loader = new CheerioWebBaseLoader(\n  "https://lilianweng.github.io/posts/2023-06-23-agent/"\n);\n\nconst docs = await loader.load();\n\nconst textSplitter = new RecursiveCharacterTextSplitter({\n  chunkSize: 1000,\n  chunkOverlap: 200,\n});\nconst splits = await textSplitter.splitDocuments(docs);\nconst vectorStore = await MemoryVectorStore.fromDocuments(\n  splits,\n  new OpenAIEmbeddings()\n);\n\n// Retrieve and generate using the relevant snippets of the blog.\nconst retriever = vectorStore.asRetriever();\n// Tip - you can edit this!\nconst prompt = await pull<ChatPromptTemplate>("rlm/rag-prompt");\nconst llm = new ChatOpenAI({ model: "gpt-3.5-turbo", temperature: 0 });\nconst ragChain = await createStuffDocumentsChain({\n  llm,\n  prompt,\n  outputParser: new StringOutputParser(),\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"Let\u2019s see what this prompt actually looks like"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'console.log(prompt.promptMessages.map((msg) => msg.prompt.template).join("\\n"));\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: {question}\nContext: {context}\nAnswer:\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'await ragChain.invoke({\n  context: await retriever.invoke("What is Task Decomposition?"),\n  question: "What is Task Decomposition?",\n});\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:'"Task Decomposition involves breaking down complex tasks into smaller and simpler steps to make them "... 243 more characters\n'})}),"\n",(0,s.jsx)(n.h2,{id:"contextualizing-the-question",children:"Contextualizing the question"}),"\n",(0,s.jsx)(n.p,{children:"First we\u2019ll need to define a sub-chain that takes historical messages\nand the latest user question, and reformulates the question if it makes\nreference to any information in the historical information."}),"\n",(0,s.jsxs)(n.p,{children:["We\u2019ll use a prompt that includes a ",(0,s.jsx)(n.code,{children:"MessagesPlaceholder"})," variable under\nthe name \u201cchat_history\u201d. This allows us to pass in a list of Messages to\nthe prompt using the \u201cchat_history\u201d input key, and these messages will\nbe inserted after the system message and before the human message\ncontaining the latest question."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import {\n  ChatPromptTemplate,\n  MessagesPlaceholder,\n} from "@langchain/core/prompts";\n\nconst contextualizeQSystemPrompt = `Given a chat history and the latest user question\nwhich might reference context in the chat history, formulate a standalone question\nwhich can be understood without the chat history. Do NOT answer the question,\njust reformulate it if needed and otherwise return it as is.`;\n\nconst contextualizeQPrompt = ChatPromptTemplate.fromMessages([\n  ["system", contextualizeQSystemPrompt],\n  new MessagesPlaceholder("chat_history"),\n  ["human", "{question}"],\n]);\nconst contextualizeQChain = contextualizeQPrompt\n  .pipe(llm)\n  .pipe(new StringOutputParser());\n'})}),"\n",(0,s.jsx)(n.p,{children:"Using this chain we can ask follow-up questions that reference past\nmessages and have them reformulated into standalone questions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { AIMessage, HumanMessage } from "@langchain/core/messages";\n\nawait contextualizeQChain.invoke({\n  chat_history: [\n    new HumanMessage("What does LLM stand for?"),\n    new AIMessage("Large language model"),\n  ],\n  question: "What is meant by large",\n});\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"'What is the definition of \"large\" in this context?'\n"})}),"\n",(0,s.jsx)(n.h2,{id:"chain-with-chat-history",children:"Chain with chat history"}),"\n",(0,s.jsx)(n.p,{children:"And now we can build our full QA chain."}),"\n",(0,s.jsx)(n.p,{children:"Notice we add some routing functionality to only run the \u201ccondense\nquestion chain\u201d when our chat history isn\u2019t empty. Here we\u2019re taking\nadvantage of the fact that if a function in an LCEL chain returns\nanother chain, that chain will itself be invoked."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import {\n  ChatPromptTemplate,\n  MessagesPlaceholder,\n} from "@langchain/core/prompts";\nimport {\n  RunnablePassthrough,\n  RunnableSequence,\n} from "@langchain/core/runnables";\nimport { formatDocumentsAsString } from "langchain/util/document";\n\nconst qaSystemPrompt = `You are an assistant for question-answering tasks.\nUse the following pieces of retrieved context to answer the question.\nIf you don\'t know the answer, just say that you don\'t know.\nUse three sentences maximum and keep the answer concise.\n\n{context}`;\n\nconst qaPrompt = ChatPromptTemplate.fromMessages([\n  ["system", qaSystemPrompt],\n  new MessagesPlaceholder("chat_history"),\n  ["human", "{question}"],\n]);\n\nconst contextualizedQuestion = (input: Record<string, unknown>) => {\n  if ("chat_history" in input) {\n    return contextualizeQChain;\n  }\n  return input.question;\n};\n\nconst ragChain = RunnableSequence.from([\n  RunnablePassthrough.assign({\n    context: async (input: Record<string, unknown>) => {\n      if ("chat_history" in input) {\n        const chain = contextualizedQuestion(input);\n        return chain.pipe(retriever).pipe(formatDocumentsAsString);\n      }\n      return "";\n    },\n  }),\n  qaPrompt,\n  llm,\n]);\n\nconst chat_history = [];\n\nconst question = "What is task decomposition?";\nconst aiMsg = await ragChain.invoke({ question, chat_history });\n\nconsole.log(aiMsg);\n\nchat_history.push(aiMsg);\n\nconst secondQuestion = "What are common ways of doing it?";\nawait ragChain.invoke({ question: secondQuestion, chat_history });\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:'AIMessage {\n  lc_serializable: true,\n  lc_kwargs: {\n    content: "Task decomposition involves breaking down a complex task into smaller and simpler steps to make it m"... 358 more characters,\n    tool_calls: [],\n    invalid_tool_calls: [],\n    additional_kwargs: { function_call: undefined, tool_calls: undefined },\n    response_metadata: {}\n  },\n  lc_namespace: [ "langchain_core", "messages" ],\n  content: "Task decomposition involves breaking down a complex task into smaller and simpler steps to make it m"... 358 more characters,\n  name: undefined,\n  additional_kwargs: { function_call: undefined, tool_calls: undefined },\n  response_metadata: {\n    tokenUsage: { completionTokens: 83, promptTokens: 701, totalTokens: 784 },\n    finish_reason: "stop"\n  },\n  tool_calls: [],\n  invalid_tool_calls: []\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:'AIMessage {\n  lc_serializable: true,\n  lc_kwargs: {\n    content: "Common ways of task decomposition include using simple prompting techniques like Chain of Thought (C"... 353 more characters,\n    tool_calls: [],\n    invalid_tool_calls: [],\n    additional_kwargs: { function_call: undefined, tool_calls: undefined },\n    response_metadata: {}\n  },\n  lc_namespace: [ "langchain_core", "messages" ],\n  content: "Common ways of task decomposition include using simple prompting techniques like Chain of Thought (C"... 353 more characters,\n  name: undefined,\n  additional_kwargs: { function_call: undefined, tool_calls: undefined },\n  response_metadata: {\n    tokenUsage: { completionTokens: 81, promptTokens: 779, totalTokens: 860 },\n    finish_reason: "stop"\n  },\n  tool_calls: [],\n  invalid_tool_calls: []\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["See the first ",(0,s.jsx)(n.a,{href:"https://smith.langchain.com/public/527981c6-5018-4b68-a11a-ebcde77843e7/r",children:"LangSmith trace\nhere"}),"\nand the ",(0,s.jsx)(n.a,{href:"https://smith.langchain.com/public/7b97994a-ab9f-4bf3-a2e4-abb609e5610a/r",children:"second trace\nhere"})]}),"\n",(0,s.jsx)(n.p,{children:"Here we\u2019ve gone over how to add application logic for incorporating\nhistorical outputs, but we\u2019re still manually updating the chat history\nand inserting it into each input. In a real Q&A application we\u2019ll want\nsome way of persisting chat history and some way of automatically\ninserting and updating it."}),"\n",(0,s.jsx)(n.p,{children:"For this we can use:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://v02.api.js.langchain.com/classes/langchain_core_chat_history.BaseChatMessageHistory.html",children:"BaseChatMessageHistory"}),":\nStore chat history."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../../docs/how_to/message_history/",children:"RunnableWithMessageHistory"}),":\nWrapper for an LCEL chain and a ",(0,s.jsx)(n.code,{children:"BaseChatMessageHistory"})," that\nhandles injecting chat history into inputs and updating it after\neach invocation."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For a detailed walkthrough of how to use these classes together to\ncreate a stateful conversational chain, head to the ",(0,s.jsx)(n.a,{href:"../../docs/how_to/message_history/",children:"How to add message\nhistory (memory)"})," LCEL page."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);